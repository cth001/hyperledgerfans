<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description" content="超级账本系列教程及分析总结"><meta name="keywords" content="Hyperledger, Fabric"><title>Fabric与dep - 超级账本解读</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.ico"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="/about"><span>About</span></a></li><li><a href="https://www.xuanzhangjiong.top"><span>Friends</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://img.mochain.info/header.jpg"><div class="post-title"><h1 class="title">Fabric与dep</h1><ul class="meta"><li><i class="icon icon-author"></i>TopJohn</li><li><i class="icon icon-clock"></i>3 Minutes</li><li><i class="icon icon-calendar"></i>January 15, 2019</li></ul></div></div><div class="article-content" style="max-width:800px"><blockquote>
<p>作者: TopJohn<br>原文连接：<a href="https://www.xuanzhangjiong.top/2019/01/15/Fabric%E4%B8%8Edep/" target="_blank" rel="noopener">https://www.xuanzhangjiong.top/2019/01/15/Fabric%E4%B8%8Edep/</a></p>
</blockquote>
<h1 id="Fabric与dep"><a href="#Fabric与dep" class="headerlink" title="Fabric与dep"></a>Fabric与dep</h1><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>接触Golang有2年时间了，从最初学习的时候简单地采用GOPATH开始，作为一个写过几年代码的人就有点奇怪，从Java的Maven到Node.js的npm，Golang的这种代码管理方式有点思维的跳跃。但是也勉强接受了，个人开发来说没什么大问题，所有的第三方包都由自己维护，但是采用Git协作的话就有点不知所云了，每个人都要维护统一的第三方包。后来就采用<a href="https://github.com/kardianos/govendor" target="_blank" rel="noopener">Govendor</a>来统一管理维护项目的第三方包。上述是个人使用经验，可能是我入<code>Golang</code>这行较晚，很多依赖管理工具没赶上潮流吧，自带学Go之后，Govendor便是主流工具。</p>
<h2 id="Fabric包管理工具的变更"><a href="#Fabric包管理工具的变更" class="headerlink" title="Fabric包管理工具的变更"></a>Fabric包管理工具的变更</h2><p>Govendor也是之前很长一段时间Hyperledger Fabric所采用的依赖管理工具，但是在17年11月22日在<a href="https://jira.hyperledger.org/browse/FAB-7083" target="_blank" rel="noopener">Jira</a>上便开始讨论是否采用dep来进行包依赖管理，毕竟在混乱的年代，第三方的包管理工具不是一个长久之计，dep当时已经成为Go的官方包管理工具的一个候选者，在1.2版本中，Fabric开始采用dep作为依赖管理工具。</p>
<p>但是在与此同时出现了vgo,然后随着go v1.11的出现，vgo又更名为go modules，真的是百家争鸣那。现在Fabric主项目采用的是dep，而fabric ca项目不知道是因为进度缓慢还是考虑到go modules会发布，还在采用govendor进行包管理。</p>
<p>在<a href="https://jira.hyperledger.org/browse/FAB-10562" target="_blank" rel="noopener">Jira</a>上，18年6月6日的时候有一个讨论，说的是vgo的提案已经被go官方接受了，Fabric团队需要考虑vgo在未来对Fabric的影响。<strong>当然下述的文字表述仅仅是对历史的一个回顾，现在vgo这个词也已经不存在了。</strong></p>
<p>Vgo的Roadmap：</p>
<ul>
<li>18年7月-计划Go v1.11 release(包括‘vgo’的预览版)</li>
<li>19年1月-计划Go v1.12 release(完全包括‘vgo’)</li>
</ul>
<h2 id="Dep-vs-Vgo"><a href="#Dep-vs-Vgo" class="headerlink" title="Dep vs Vgo"></a>Dep vs Vgo</h2><p>dep和vgo主要的差异在于，dep是一个单独的依赖管理工具，而vgo则是go命令的一个替代品。当你运行<code>vgo build</code>时，就像运行<code>go build</code>，但是vgo会自动帮你解决依赖。<br>vgo采用go.mod文件来追踪依赖，而不是dep的Gopkg.lock和Gopkg.toml文件。</p>
<p>使用vgo同样允许链码相关的依赖在安装的时候能够自动下载并导入到二进制中。这意味着我们可以忽略vendor目录就像node_modules目录一样。</p>
<h2 id="说说Chaincode中的包管理"><a href="#说说Chaincode中的包管理" class="headerlink" title="说说Chaincode中的包管理"></a>说说Chaincode中的包管理</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>如果一个用户写了一个带有几个外部依赖的链码程序。他将采用dep去管理依赖和shim层。然而他们并不想提交大量的文件，因为链码程序仅仅是个小的代码库。</p>
<h3 id="当前的实现"><a href="#当前的实现" class="headerlink" title="当前的实现"></a>当前的实现</h3><p>在进行install的时候，为了保证所有的依赖都被包括进链码的容器里，用户被要求强制提交vendor目录，否则编译将会失败。</p>
<h3 id="建议的实现"><a href="#建议的实现" class="headerlink" title="建议的实现"></a>建议的实现</h3><p>当链码构建的时候，我们会搜索Gopkg.toml和Gopkg.lock文件。如果它们存在的话，我们会运行<code>dep ensure</code>命令。这将会从相关的源头获取相关的依赖，然后不需要用户提交依赖的前提下将依赖构建进二进制中。</p>
<p>要值得注意的是，如果用户希望提交vendor目录（比如peer节点无法拉取相应的依赖的情况下），这仍然有效-而且还有个好处是使用<code>dep ensure</code>-将保证提交的依赖是通过校验的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人观点，自从Golang v1.11发布之后go modules的出现，Fabric采用原生go modules替代dep是迟早的事，在<a href="https://github.com/golang/dep" target="_blank" rel="noopener">Github</a>中，已经明确发现了dep现在的迭代只是因为go modules还不太稳定。想必在19年Fabric会逐渐替换dep以及Fabric CA中的govendor，希望go modules可以终结Golang混乱的包管理机制。</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabric/">Fabric</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fabric-笔记/">Fabric 笔记</a><span class="tag-list-count">1</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Fabric/">Fabric</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Fabric/Fabric-笔记/">Fabric 笔记</a><span class="category-list-count">1</span></li></ul></li></ul></div></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2020/01/08/超级账本解读大纲/"><i class="icon icon-arror-left"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/TopJohn" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="http://weibo.com/xuanzhangjiong" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.zhihu.com/people/topjohn" title="zhihu" target="_blank"><i class="icon icon-zhihu"></i></a></li><li><a href="mailto:xzj19922010@gmail.com" target="_blank"><i class="icon icon-email"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2019 超级账本解读</p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>